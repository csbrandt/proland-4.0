/*! \page page-examples Examples

\htmlonly
<div class="mainpage">
\endhtmlonly

\section sec-trees1 Trees1 example

\htmlonly
<img src="trees1.png"><br/>
\endhtmlonly

\htmlonly <!-- \endhtmlonly
\image html trees1.png
\htmlonly --> \endhtmlonly

This example adds billboard trees to the "terrain3" example.

\subsection sec-trees1-lcc Lcc map

The first step to add such trees is to provide a tree density
map, so that trees will be instantiated only where this density
is not null.
For this we define a tile cache to store the tiles of this density
map (we call it a "land cover classification" map, or LCC map, because
it contains in general more than one density - although here we use
only one):

\dontinclude trees1/helloworld.xml
\skip groundLccGpu
\until /tileCache

Here we specify that our LCC tiles are 100x100 pixels (including borders),
and have 1 channel per pixel. We can then define an ortho producer
to produce these LCC tiles. Here we want a fractal noise, modified based
on the local terrain elevation and slope, in order to avoid planting
trees in the oceans or in cliffs. For this we use an ortho producer 
(to produce the raw noise) with two layers (one to exclude ocean areas,
the other to exclude cliffs - note that we said earlier that an ortho producer 
cannot have layers: in fact this is possible in practice, but generally
does not give meaningful results. Here is an exception that proves
the rule):

\dontinclude trees1/helloworld.xml
\skip "groundLccGpu1"
\until /orthoProducer

The raw ortho producer is defined in a similar way as in the "terrain3"
example, except that we use a slightly different upsample and add shader.
The first layer modifies the raw densities generated by this producer,
based on the normal tiles produced by the "groundNormals1" producer, and
used via the "fragmentNormalSampler" uniform in the "slopeFilter" shader.
This shader computes a color and an alpha mask, based on these normals,
which is then blended in the raw density map (here no blending mode is
specified in the layer definition, so the default mode is used - ADD with
SRC_ALPHA and ONE_MINUS_SRC_ALPHA):

\dontinclude trees1/slopeFilter.glsl
\skip fragmentNormalSampler
\until }

Here the output color is black (i.e., density 0) and the alpha mask is
one when the slope is high. The result, after blending, is that the 
tree density is set to 0 in areas where the slope is high.
The second layer is similar, and sets the tree density to zero when
the altitude is less than 4:

\dontinclude trees1/elevationFilter.glsl
\skip elevationSampler
\until }

\subsection sec-trees1-plants Trees specification

Once we have a tree density map, the next step is to specify how
we want to instantiate trees based on this map. This is done as
follows:

\dontinclude trees1/helloworld.xml
\skip <plants
\until </plants 

This specifies that trees will be instantiated for terrain quads
whose level in the quadtree is between 5 and 7, that no trees will
be visible at a distance more than 5000, and that for each terrain 
quad at level 7, 8500 trees will be instantiated (4 times more for
quads at level 6, and 16 times more at level 5 - the maximum number
of instantiated trees will be 400x8500=3400000). For each quad at 
level 7 a random point pattern will be used to instantiate the
trees, chosen at random amongst 10 precomputed patterns.

The "selectProg" program is responsible to remove some points
from these patterns, in order to generate the desired tree density
(based on the LCC map produced above). It is also responsible to
generate some attributes for these points, based on random seeds
associated with each point, and optionally on external maps (color, 
elevation, normal, etc). For instance a very important attribute is
the tree altitude, which can be generated by sampling an elevation
tile (see below). 

Finally the "renderProg"
program will be responsible to generate camera facing quads from
these points, and to texture and shade them (it is also possible
to specify a "shadowProg" in order to render the trees in cascaded
shadow maps, in order to simulate the shadows of trees, but we do
not use it here).

The "selectProg" shader receives as input a point pattern, where
each point has xy coordinates in the [0,1] range, and a z coordinate
encoding four random bytes. It may discard some points, and must 
output for the remaining points at most two vec3 values. In this 
example the "selectTreeShader" outputs a xyz position on the terrain
for each point, in a first vec3, as well as the terrain normal,
a random color, a random size, and a random value, packed in a
second vec3:

\dontinclude trees1/selectTreeShader.glsl
\skip pt[]
\until }
\until }

This code discards the input point pt if the tree density at this
point, given by lccSampler, is less than 0.25. For the remaining
points, the terrain height and normal are read from the 
elevationSampler and fragmentNormalSampler tile samplers, the
random bytes are extracted from the z coordinate of pt, and the
tree position and attributes are computed and output in "pos"
and "params". Note that, in order for these outputs to be stored
in a VBO for use during rendering, you must enable transform
feedback for them:

\dontinclude trees1/helloworld.xml
\skip "selectTreeShader.glsl"
\until feedback

During rendering the "renderTreeShader.glsl" reads these points,
discards those outside the view frustum based on the "clip"
uniforms set by proland::DrawPlantsTask, and generates a camera
facing quad for the others (using the size attribute generated
by the previous shader). It then shades these quads by using the
random color, and the terrain normal stored for each tree
by the previous shader.

\subsection sec-trees1-node Trees scene node

Finally, in order to generate and draw the trees, it is necessary
to add a scene node for them in the scene graph:

\dontinclude trees1/helloworld.xml
\skip name="plants"
\until /node

Here we specify two methods. The "shadow" method is the following:

\include trees1/drawPlantsShadowMethod.xml

It generates the trees for the newly created terrain quads at 
each frame. It also renders the trees in cascaded shadow maps, if a
"shadow" prog is specified in the "trees" resource. This method
must be called after the terrain quadtree is updated, but before
the trees are rendered. For this we add a loop in the camera method,
over all objects having the "shadow" flag (which is the case of the
above scene node), between the update and draw loops:

\dontinclude trees1/helloworld.xml
\skip name="cameraMethod"
\until </sequence

The "draw" method is the following:

\include trees1/drawPlantsMethod.xml

\note both methods expects the scene node to contain a "terrain" field,
specifying on which terrain scene node the trees must be 
instantiated. If this scene node has a tile sampler whose name is 
"elevation", "fnormal" or "lcc", then the corresponding GLSL uniform
will be set in the "selectProg" above, so that it can use this external
data to generate attributes for each tree.

*/
